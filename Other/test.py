# a = 1
# b = 2 - 1
# print(a is b)
#
# a = 'ab'
# b = 'a' + 'b'
# print(a is b)

# def is_palindrome(text):
#     return text == text[::-1]
#
# print(is_palindrome("lalal"))

#
# palindrome = lambda text: text == text[::-1]
# print(palindrome("heheh"))

a = ([],)
a[0].extend([1])
print(a[0] == [1])

"""
Tuples всегда immutable, то есть кортежи модифицировать нельзя. 
Однако, список, на который ссылаются из кортежа, не является частью кортежа. 
Он не "знает", что находится в кортеже, так что .extend() сработает. Поэтому True"""

# T = (4, 2, 3)
# L = (1)
# print(type(T))

"""

С .append() только синтаксис немного другой будет, a[0].append(1). 
Без квадратных скобок в конце, потому что иначе .append() добавит элемент как list,
и тогда в итоге было бы False. Если оставить c квадратными, то сравнивать надо будет
уже a[0][0] == [1], а не a[0] == [1].

a = ([],)
a[0].append([1])
print(a[0][0] == [1])

print(type(a[0][0]))
"""

for i in range(5):
    if i % 2 == 0:
        continue
    print(i, end=" ")
"""
Ответ: 1 3.

range начинается с 0, и заканчивается перед указанным числом, 
то есть в нашем случае это промежуток [0, 5), иными словами - [0, 4].
continue останавливает нынешнюю итерацию, и сразу переходит к следующей.

Если i mod 0, то есть если число чётное, то мы его не печатаем. 
Остаётся напечатать все нечётные в промежутке [0, 4], а это как раз 1 и 3.
"""
# print(0 % 2)

print("------")
a2 = [3, -3, 3, 3]
del a2[0:-2:1]
print(a2)

"""
Ответ: 1

Сначала у нас slicing, указан только stop -2, само значение stop у нас исключено из промежутка.
Ошибки из-за последней точки в [:-2:] не будет, так как это то же самое, что и [:-2:1] или [0:-2:1]. 
Итак, a2[:-2:] - это 3 и -3, то есть первые два элемента. С помощью del удаляем их - остаются только 3 и 3. 
Переводим [3, 3] в set, остаётся только 3, потому что set’ы не хранят дубликаты. 
Ну и длина set’а, соответственно, 1.

"""


"""
c = [3, 5]
b = c.append(1)
print(b[1])
метод append класса list возвращает None и самая нижняя строка пытается найти индекс 
в объекта None у которого нет метода get_item что производит к такой ошибке
"""


i = 0
while i < 3:
    print(i)
    i += 1
    print(i + 1)



l = max(-0.0, 0.0)
s = 'quiz'
print(l, "+", s * (-1))

"""
Функция max() возвращает первый по порядку элемент с максимальным значением, 
а так как -0.0 и 0.0 равны, а -0.0 стоит раньше, то max и вернет -0.0
"""

print(("June" > "July"))
"""
J = J -> next
u = u -> next
n > l -> True
"""
s1 = "June"
k = 0.2 * 10
print(s1 * int(k))



x = float('nan')
print(x == x)

"""
 nan обозначает "не число", по сути это хоть и строка, но его тип - float.
 И его каверзность заключается в том, что этот объект не ссылается
 каждый раз на свой идентификатор, а создаёт новый, поэтому в 1 тесте и выдало false"""


"""
Python's map() is a built-in function that allows you 
to process and transform all the items in an iterable
without using an explicit for loop
"""

lst = ["java", "c++", "python"]
lst = map(str.capitalize, lst)
print(*lst)  # or print(list(lst))
